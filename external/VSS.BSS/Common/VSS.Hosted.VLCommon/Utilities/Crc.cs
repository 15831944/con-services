using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace VSS.Hosted.VLCommon
{
  public static class Crc
  {
    /// <summary></summary>
    /// <param name="rawData"></param>
    /// <param name="startIndex"></param>
    /// <param name="rawLength"></param>
    /// <returns></returns>
    public static byte CalculateCrc8(byte[] rawData, int startIndex, int rawLength)
    {
      byte result = 0;

      rawLength += startIndex;

      for (int i = startIndex; i < rawLength; i++)
      {
        result = crc8Table[result ^ rawData[i]];
      }

      return result;
    }
    /* table for CRC-8 generation                                             */
    /* this table embeds the polynomial g(x) = x^8 + x^6 + x^4 + x^3 +x^1 + 1 */

    private static readonly byte[] crc8Table = new byte[]
                                              {
                                                 0x00,0x5b,0xb6,0xed,0x37,0x6c,0x81,0xda,0x6e,0x35,0xd8,0x83,0x59,0x02,0xef,0xb4,
                                                 0xdc,0x87,0x6a,0x31,0xeb,0xb0,0x5d,0x06,0xb2,0xe9,0x04,0x5f,0x85,0xde,0x33,0x68,
                                                 0xe3,0xb8,0x55,0x0e,0xd4,0x8f,0x62,0x39,0x8d,0xd6,0x3b,0x60,0xba,0xe1,0x0c,0x57,
                                                 0x3f,0x64,0x89,0xd2,0x08,0x53,0xbe,0xe5,0x51,0x0a,0xe7,0xbc,0x66,0x3d,0xd0,0x8b,
                                                 0x9d,0xc6,0x2b,0x70,0xaa,0xf1,0x1c,0x47,0xf3,0xa8,0x45,0x1e,0xc4,0x9f,0x72,0x29,
                                                 0x41,0x1a,0xf7,0xac,0x76,0x2d,0xc0,0x9b,0x2f,0x74,0x99,0xc2,0x18,0x43,0xae,0xf5,
                                                 0x7e,0x25,0xc8,0x93,0x49,0x12,0xff,0xa4,0x10,0x4b,0xa6,0xfd,0x27,0x7c,0x91,0xca,
                                                 0xa2,0xf9,0x14,0x4f,0x95,0xce,0x23,0x78,0xcc,0x97,0x7a,0x21,0xfb,0xa0,0x4d,0x16,
                                                 0x61,0x3a,0xd7,0x8c,0x56,0x0d,0xe0,0xbb,0x0f,0x54,0xb9,0xe2,0x38,0x63,0x8e,0xd5,
                                                 0xbd,0xe6,0x0b,0x50,0x8a,0xd1,0x3c,0x67,0xd3,0x88,0x65,0x3e,0xe4,0xbf,0x52,0x09,
                                                 0x82,0xd9,0x34,0x6f,0xb5,0xee,0x03,0x58,0xec,0xb7,0x5a,0x01,0xdb,0x80,0x6d,0x36,
                                                 0x5e,0x05,0xe8,0xb3,0x69,0x32,0xdf,0x84,0x30,0x6b,0x86,0xdd,0x07,0x5c,0xb1,0xea,
                                                 0xfc,0xa7,0x4a,0x11,0xcb,0x90,0x7d,0x26,0x92,0xc9,0x24,0x7f,0xa5,0xfe,0x13,0x48,
                                                 0x20,0x7b,0x96,0xcd,0x17,0x4c,0xa1,0xfa,0x4e,0x15,0xf8,0xa3,0x79,0x22,0xcf,0x94,
                                                 0x1f,0x44,0xa9,0xf2,0x28,0x73,0x9e,0xc5,0x71,0x2a,0xc7,0x9c,0x46,0x1d,0xf0,0xab,
                                                 0xc3,0x98,0x75,0x2e,0xf4,0xaf,0x42,0x19,0xad,0xf6,0x1b,0x40,0x9a,0xc1,0x2c,0x77
                                              };

    /// <summary>
    /// Computes and returns the CRC-32 value for the given string of bytes. If you call this
    /// method with raw data to send, you get back the CRC value to append to the data.  If you
    /// pass in the raw data packet with the CRC byte at the end, you'll get a zero back if the
    /// CRC passed.
    /// </summary>
    public static UInt32 CalculateCrc32(byte[] rawData)
    {
      return CalculateCrc32(rawData, 0, rawData.Length);
    }

    /// <summary></summary>
    /// <param name="rawData"></param>
    /// <param name="startIndex"></param>
    /// <param name="rawLength"></param>
    /// <returns></returns>
    public static UInt32 CalculateCrc32(byte[] rawData, int startIndex, int rawLength)
    {
      // Calculate our table used for the polynomial.

      if (table32 == null)
      {
        table32 = new UInt32[256];

        UInt32 accum;

        for (int address = 0; address < 256; address++)
        {
          accum = (UInt32)(address << 24);

          for (int index = 0; index < 8; index++)
          {
            if ((accum & 0x80000000) != 0)
            {
              accum = (accum << 1) ^ 0x04C11DB7 /* polynomial value */;
            }
            else
            {
              accum = (accum << 1);
            }
          }

          table32[address] = accum;
        }
      }

      UInt32 result = 0;

      rawLength += startIndex;

      for (int index = startIndex; index < rawLength; index++)
      {
        result = (result << 8) ^ table32[(byte)(result >> 24) ^ rawData[index]];
      }

      result ^= 0xFFFFFFFF;

      return result;
    }

    static private UInt32[] table32;


  }
}
