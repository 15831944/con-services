using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using VSS.TRex.Common;
using VSS.TRex.GridFabric.Interfaces;
using VSS.TRex.SiteModels.Interfaces;
using VSS.TRex.Storage.Interfaces;
using VSS.TRex.SubGridTrees.Interfaces;
using VSS.TRex.SubGridTrees.Server.Interfaces;
using VSS.TRex.SubGridTrees.Server.Iterators;
using VSS.TRex.SubGridTrees.Server.Utilities;
using VSS.TRex.SubGridTrees.Types;
using VSS.TRex.TAGFiles.Types;

namespace VSS.TRex.TAGFiles.Classes.Integrator
{
  /// <summary>
  /// Responsible for orchestrating integration of mini site models processed from one or
  /// more TAG files into another site model, either a temporary/transient artifact of the ingest
  /// pipeline, or the persistent data store.
  /// </summary>
  public class SubGridIntegrator
  {
    private static readonly ILogger _log = Logging.Logger.CreateLogger<SubGridIntegrator>();

    /// <summary>
    /// The sub grid tree from which information is being integrated
    /// </summary>
    private readonly IServerSubGridTree _source;

    /// <summary>
    /// Site model representing the target sub grid tree
    /// </summary>
    private readonly ISiteModel _siteModel;

    /// <summary>
    /// The sub grid tree the receives the sub grid information from the source sub grid tree
    /// </summary>
    private readonly IServerSubGridTree _target;

    private readonly IStorageProxy _storageProxy;

    public readonly List<ISubGridSpatialAffinityKey> InvalidatedSpatialStreams = new List<ISubGridSpatialAffinityKey>(100);

    /*
    /// <summary>
    /// The version number to stamp spatial data elements with generated by this worker.
    /// Commented out pending requirement for request based consistency requiring a sub grid version map
    /// </summary>
    //private long EpochVersion { get; } = DateTime.UtcNow.Ticks;
    */

    /// <summary>
    /// Constructor the initializes state ready for integration
    /// </summary>
    /// <param name="source">The sub grid tree from which information is being integrated</param>
    /// <param name="siteModel">The site model representing the target sub grid tree</param>
    /// <param name="target">The sub grid tree into which the data from the source sub grid tree is integrated</param>
    /// <param name="storageProxy">The storage proxy providing storage semantics for persisting integration results</param>
    public SubGridIntegrator(IServerSubGridTree source, ISiteModel siteModel, IServerSubGridTree target, IStorageProxy storageProxy)
    {
      _source = source;
      _siteModel = siteModel;
      _target = target;
      _storageProxy = storageProxy;
    }

    private void IntegrateIntoIntermediaryGrid(IServerLeafSubGrid sourceSubGrid, ISubGridSegmentIterator segmentIterator)
    {
      var targetSubGrid = _target.ConstructPathToCell(sourceSubGrid.OriginX,
        sourceSubGrid.OriginY,
        SubGridPathConstructionType.CreateLeaf) as IServerLeafSubGrid;
      targetSubGrid.AllocateLeafFullPassStacks();

      // If the node is brand new (ie: it does not have any cell passes committed to it yet)
      // then create and select the default segment
      if (targetSubGrid.Directory.SegmentDirectory.Count == 0)
      {
        targetSubGrid.Cells.SelectSegment(Consts.MIN_DATETIME_AS_UTC);
        targetSubGrid.Cells.PassesData[0].AllocateFullPassStacks();
      }

      if (targetSubGrid.Cells.PassesData[0].PassesData == null)
      {
        _log.LogCritical("No segment passes data in new segment");
        return;
      }

      // As the integration is into the intermediary grid, these segments do not
      // need to be involved with the cache, so instruct the iterator to not 'touch' them
      segmentIterator.MarkReturnedSegmentsAsTouched = false;

      targetSubGrid.Integrate(sourceSubGrid, segmentIterator, true);
    }

    private bool IntegrateIntoLiveDatabase(IServerLeafSubGrid sourceSubGrid,
      IServerLeafSubGrid targetSubGrid,
      ISubGridSegmentIterator segmentIterator,
      Action<int, int> subGridChangeNotifier)
    {
      // Note the fact that this sub grid will be changed and become dirty as a result
      // of the cell pass integration
      targetSubGrid.SetDirty();

      // As the integration is into the live database these segments do
      // need to be involved with the cache, so instruct the iterator to
      // 'touch' them
      segmentIterator.MarkReturnedSegmentsAsTouched = true;

      targetSubGrid.Integrate(sourceSubGrid, segmentIterator, false);

      subGridChangeNotifier?.Invoke(targetSubGrid.OriginX, targetSubGrid.OriginY);

      // Save the integrated state of the sub grid segments to allow Ignite to store & socialize the update
      // within the cluster. 

      // Failure to save a piece of data aborts the entire integration
      var result = false;
      if (_target.SaveLeafSubGrid(targetSubGrid, segmentIterator.StorageProxy, InvalidatedSpatialStreams))
      {
        // Successfully saving the sub grid directory information is the point at which this sub grid may be recognized to exist
        // in the site model. Note this by including it within the SiteModel existence map

        _siteModel.ExistenceMap.SetCell(targetSubGrid.OriginX >> SubGridTreeConsts.SubGridIndexBitsPerLevel,
          targetSubGrid.OriginY >> SubGridTreeConsts.SubGridIndexBitsPerLevel,
          true);
        result = true;
      }
      else
      {
        _log.LogError($"Sub grid leaf save failed for {targetSubGrid}, existence map not modified.");
      }

      // Finally, mark the source sub grid as not being dirty. We need to do this to allow
      // the sub grid to permit its destruction as all changes have been merged into the target.
      if (result)
        sourceSubGrid.AllChangesMigrated();

      return result;
    }

    private void IntegrateIntoLiveGrid(IServerLeafSubGrid sourceSubGrid,
      ISubGridSegmentIterator segmentIterator,
      Action<int, int> subGridChangeNotifier)
    {
      var targetSubGrid = LocateOrCreateSubGrid(_target, sourceSubGrid.OriginX, sourceSubGrid.OriginY);

      try
      {
        if (targetSubGrid == null)
        {
          _log.LogError("Failed to locate or create sub grid in IntegrateIntoLiveGrid");
          return;
        }

        if (!IntegrateIntoLiveDatabase(sourceSubGrid, targetSubGrid, segmentIterator, subGridChangeNotifier))
        {
          _log.LogError("Integration into live database failed");
        }
      }
      finally
      {
        // At this point TargetSubGrid is of no further interest. The site model will be dropped in-toto once all 
        // changes have been integrated into the live sub grids and releasing it's resources here alleviates memory
        // pressure that occurs if all sub grids are integrated before any resource freeing occurs
        // This is not mediated by a using block as we want the sub grid to remain in the sub grid tree (ie:
        // removing it is messy and not necessary here, it can be delegated to the DropSiteModel() phase.
        targetSubGrid?.DeAllocateLeafFullPassStacks();
        targetSubGrid?.DeAllocateLeafLatestPassGrid();
      }
    }

    private void IntegrateSubGrid(IServerLeafSubGrid sourceSubGrid,
      SubGridTreeIntegrationMode integrationMode,
      Action<int, int> subGridChangeNotifier,
      ISubGridSegmentIterator segmentIterator)
    {
      // Locate a matching sub grid in this tree. If there is none, then create it
      // and assign the sub grid from the iterator to it. If there is one, process
      // the cell pass stacks merging the two together

      var integratingIntoIntermediaryGrid = integrationMode == SubGridTreeIntegrationMode.UsingInMemoryTarget;
      if (integratingIntoIntermediaryGrid)
        IntegrateIntoIntermediaryGrid(sourceSubGrid, segmentIterator);
      else
        IntegrateIntoLiveGrid(sourceSubGrid, segmentIterator, subGridChangeNotifier);
    }

    public bool IntegrateSubGridTree(SubGridTreeIntegrationMode integrationMode,
      Action<int, int> subGridChangeNotifier)
    {
      // Iterate over the sub grids in source and merge the cell passes from source
      // into the sub grids in this sub grid tree;

      var iterator = new SubGridTreeIterator(_storageProxy, false) {Grid = _source};

      var segmentIterator = new SubGridSegmentIterator(null, _storageProxy) {IterationDirection = IterationDirection.Forwards};

      while (iterator.MoveToNextSubGrid())
      {
        var sourceSubGrid = iterator.CurrentSubGrid as IServerLeafSubGrid;

        /*
         // TODO: Terminated check for integration processing
        if (Terminated)
        {
            // Service has been shutdown. Abort integration of changes and flag the
            // operation as failed. The TAG file will be reprocessed when the service restarts
            return false;
        }
        */
        IntegrateSubGrid(sourceSubGrid, integrationMode, subGridChangeNotifier, segmentIterator);

        // Release the resources used by SourceSubGrid as this is the last point it is needed
        sourceSubGrid?.DeAllocateLeafFullPassStacks();
        sourceSubGrid?.DeAllocateLeafLatestPassGrid();
      }

      return true;
    }

    /// <summary>
    /// Creates a set of tasks for each sub grid in the integrated sub grid tree and executes them concurrently 
    /// </summary>
    public bool IntegrateSubGridTreeParallelisedTasks(SubGridTreeIntegrationMode integrationMode,
      Action<int, int> subGridChangeNotifier)
    {
      void ProcessSubGrid(IServerLeafSubGrid sourceSubGrid,
        SubGridTreeIntegrationMode integrationModeLocal,
        Action<int, int> subGridChangeNotifierLocal)
      {
        try
        {
          IntegrateSubGrid(sourceSubGrid, integrationModeLocal, subGridChangeNotifierLocal, new SubGridSegmentIterator(null, _storageProxy));
        }
        catch (Exception e)
        {
          // Log the exception as this code is being run within a Task
          _log.LogError(e, "Error occurred during Task based execution of data integration");
        }
      }

      // Iterate over the sub grids in source and merge the cell passes from source
      // into the sub grids in this sub grid tree;

      var iterator = new SubGridTreeIterator(_storageProxy, false) {Grid = _source};

      var tasks = new List<Task>();
      while (iterator.MoveToNextSubGrid())
      {
        var subGrid = iterator.CurrentSubGrid as IServerLeafSubGrid;
        tasks.Add(Task.Run(() => ProcessSubGrid(subGrid, integrationMode, subGridChangeNotifier)));
      }

      var completionTask = Task.WhenAll(tasks);
      completionTask.Wait();

      return true;
    }

    /// <summary>
    /// Locates a sub grid in within this site model. If the sub grid cannot be found it will be created.
    /// If requested from an immutable grid context, the result of this call should be considered as an immutable
    /// copy of the requested data that is valid for the duration the request holds a reference to it. Updates
    /// to sub grids in this data model from ingest processing and other operations performed in mutable contexts
    /// can occur while this request is in process, but will not affected the immutable copy initially requested.
    /// If requested from a mutable grid context the calling context is responsible for ensuring serialized write access
    /// to the data elements being requested. 
    /// </summary>
    // ReSharper disable once MemberCanBePrivate.Global
    public IServerLeafSubGrid LocateOrCreateSubGrid(IServerSubGridTree grid, int cellX, int cellY)
    {
      var result = SubGridUtilities.LocateSubGridContaining(
        _storageProxy,
        grid,
        // DataStoreInstance.GridDataCache,
        cellX, cellY,
        grid.NumLevels,
        false, true) as IServerLeafSubGrid;

      // Ensure the cells and segment directory are initialized if this is a new sub grid
      if (result != null)
      {
        // By definition, any new sub grid we create here is dirty, even if we
        // ultimately do not add any cell passes to it. This is necessary to
        // encourage even otherwise empty sub grids to be persisted to disk if
        // they have been created, but never populated with cell passes.
        // The sub grid persistent layer may implement a rule that no empty
        // sub grids are saved to disk if this becomes an issue...
        result.SetDirty();

        result.AllocateLeafFullPassStacks();
        if (result.Directory.SegmentDirectory.Count == 0)
        {
          result.Cells.SelectSegment(Consts.MIN_DATETIME_AS_UTC);
        }

        if (result.Cells == null)
        {
          _log.LogCritical($"LocateSubGridContaining returned a sub grid {result.Moniker()} with no allocated cells");
        }
        else if (result.Directory.SegmentDirectory.Count == 0)
        {
          _log.LogCritical($"LocateSubGridContaining returned a sub grid {result.Moniker()} with no segments in its directory");
        }
      }
      else
      {
        _log.LogCritical($"LocateSubGridContaining failed to return a sub grid (CellX/Y={cellX}/{cellY})");
      }

      return result;
    }
  }
}
